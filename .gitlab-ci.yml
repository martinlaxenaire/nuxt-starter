image: node:16

stages:
    - test
    - build
    - docker
    - release

# AutoDevOps templates for security
include:
    - template: Jobs/Secret-Detection.gitlab-ci.yml
    - template: Jobs/Dependency-Scanning.gitlab-ci.yml

.cache: &cache
    cache:
        key:
            files:
                - yarn.lock
        paths:
            - node_modules

.staging-env: &staging-env
    environment:
        name: staging
        url: "https://my-staging-env.dev"
    variables:
        NUXT_APP_CHANNEL: "$CI_COMMIT_SHORT_SHA $CI_ENVIRONMENT_NAME"

.production-env: &production-env
    environment:
        name: production
        url: "https://my-production-env.dev"
    variables:
        NUXT_APP_CHANNEL: "$CI_COMMIT_SHORT_SHA $CI_ENVIRONMENT_NAME"

.storybook-env: &storybook-env
    environment:
        name: storybook
        url: "https://my-storybook-env.dev"
    variables:
        NUXT_APP_CHANNEL: "$CI_COMMIT_SHORT_SHA $CI_ENVIRONMENT_NAME"

## Common scripts and artifacts for develop and main jobs
.build-commons: &build-commons
    artifacts:
        name: "build_${CI_COMMIT_REF_NAME}_${CI_COMMIT_SHORT_SHA}"
        expire_in: 1 hour
        paths:
            - .nuxt/
            - node_modules/
    script:
        - yarn install --pure-lockfile
        - yarn lint
        - yarn build

# ===========
# SSR STAGING
# ===========
ssr_build_develop:
    stage: build
    interruptible: true
    only:
        - merge_requests
        - develop
    except:
        - tags
        - main
    <<: *cache
    <<: *staging-env
    <<: *build-commons

ssr_docker_develop:
    stage: docker
    only:
        - develop
    image: docker:git
    services:
        - docker:dind
    when: on_success
    <<: *staging-env
    needs: [ "ssr_build_develop" ]
    dependencies: [ "ssr_build_develop" ]
    script:
        - "docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}"
        # App image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/node -f .docker/node/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/node ${CI_REGISTRY_IMAGE}/node:develop"
        - "docker push ${CI_REGISTRY_IMAGE}/node:develop"
        # NGINX image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/nginx -f .docker/nginx/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/nginx ${CI_REGISTRY_IMAGE}/nginx:develop"
        - "docker push ${CI_REGISTRY_IMAGE}/nginx:develop"
        # Varnish image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/varnish -f .docker/varnish/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/varnish ${CI_REGISTRY_IMAGE}/varnish:develop"
        - "docker push ${CI_REGISTRY_IMAGE}/varnish:develop"

# =============
# SSG Storybook
# =============
storybook_build_develop:
    stage: build
    interruptible: true
    <<: *cache
    <<: *storybook-env
    only:
        - develop
    artifacts:
        expire_in: 1 hour
        paths:
            - storybook-static/
    script:
        - cp .env.storybook .env
        - yarn install --pure-lockfile
        - yarn storybook:build

storybook_docker_develop:
    stage: docker
    only:
        - develop
    image: docker:git
    services:
        - docker:dind
    <<: *storybook-env
    when: on_success
    needs: [ "storybook_build_develop" ]
    dependencies: [ "storybook_build_develop" ]
    script:
        - "docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}"
        # App image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/storybook-static -f .docker/storybook-static/Dockerfile ."
        - "docker push ${CI_REGISTRY_IMAGE}/storybook-static"

# ========
# SSR PROD
# ========
ssr_build_tags:
    stage: build
    interruptible: true
    only:
        - tags
    <<: *cache
    <<: *production-env
    <<: *build-commons

ssr_docker_tags:
    stage: docker
    only:
        - tags
    image: docker:git
    <<: *production-env
    services:
        - docker:dind
    when: on_success
    needs: [ "ssr_build_tags" ]
    dependencies: [ "ssr_build_tags" ]
    script:
        # Connect to your Gitlab Registry
        - "docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}"
        # App image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/node -f .docker/node/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/node ${CI_REGISTRY_IMAGE}/node:${CI_COMMIT_TAG}"
        - "docker push ${CI_REGISTRY_IMAGE}/node:latest"
        - "docker push ${CI_REGISTRY_IMAGE}/node:${CI_COMMIT_TAG}"
        # NGINX image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/nginx -f .docker/nginx/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/nginx ${CI_REGISTRY_IMAGE}/nginx:${CI_COMMIT_TAG}"
        - "docker push ${CI_REGISTRY_IMAGE}/nginx:latest"
        - "docker push ${CI_REGISTRY_IMAGE}/nginx:${CI_COMMIT_TAG}"
        # Varnish image build
        - "docker build -t ${CI_REGISTRY_IMAGE}/varnish -f .docker/varnish/Dockerfile ."
        - "docker tag ${CI_REGISTRY_IMAGE}/varnish ${CI_REGISTRY_IMAGE}/varnish:${CI_COMMIT_TAG}"
        - "docker push ${CI_REGISTRY_IMAGE}/varnish:latest"
        - "docker push ${CI_REGISTRY_IMAGE}/varnish:${CI_COMMIT_TAG}"

create_gitlab_release:
    stage: release
    image: registry.gitlab.com/gitlab-org/release-cli:latest
    rules:
        - if: $CI_COMMIT_TAG
    script:
        - echo "Running the release job."
    needs: [ "ssr_docker_tags" ]
    <<: *production-env
    when: on_success
    release:
        tag_name: $CI_COMMIT_TAG
        name: 'Release $CI_COMMIT_TAG'
        description: './CHANGELOG.md'


# ===================
# Static site STAGING
# ===================
#static_build_develop:
#    stage: build
#    interruptible: true
#    <<: *cache
#    only:
#        - merge_requests
#        - develop
#    artifacts:
#        expire_in: 1 hour
#        paths:
#            - dist/
#    script:
#        ## Use Gitlab CI/CD secrets to store your API key.
#        - echo "$API_KEY"
#        # Static site generation requires a .env.test
#        - cp .env.test .env
#        - yarn install --pure-lockfile
#        - yarn lint
#        - yarn generate
#
#static_docker_develop:
#    stage: docker
#    only:
#        - develop
#    image: docker:git
#    services:
#        - docker:dind
#    when: on_success
#    needs: [ "static_build_develop" ]
#    dependencies: [ "static_build_develop" ]
#    script:
#        # Connect to your Gitlab Registry
#        - "echo \"Registry image: ${CI_REGISTRY_IMAGE} for develop\""
#        - "docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}"
#        # App image build
#        - "docker build -t ${CI_REGISTRY_IMAGE} -f .docker/nginx-static/Dockerfile ."
#        - "docker tag ${CI_REGISTRY_IMAGE} ${CI_REGISTRY_IMAGE}:develop"
#        - "docker push ${CI_REGISTRY_IMAGE}:develop"


# ================
# Static site PROD
# ================
#static_build_tags:
#    stage: build
#    interruptible: true
#    <<: *cache
#    only:
#        - tags
#    artifacts:
#        expire_in: 1 hour
#        paths:
#            - dist/
#    script:
#        ## Use Gitlab CI/CD secrets to store your API key.
#        - echo "$API_KEY"
#        # Static site generation requires a .env.prod
#        - cp .env.prod .env
#        - yarn install --pure-lockfile
#        - yarn lint
#        - yarn generate
#
#static_docker_tags:
#    stage: docker
#    only:
#        - tags
#    image: docker:git
#    services:
#        - docker:dind
#    when: on_success
#    needs: [ "static_build_tags" ]
#    dependencies: [ "static_build_tags" ]
#    script:
#        # Connect to your Gitlab Registry
#        - "echo \"Registry image: ${CI_REGISTRY_IMAGE} for ${CI_COMMIT_TAG}\""
#        - "docker login -u gitlab-ci-token -p ${CI_JOB_TOKEN} ${CI_REGISTRY}"
#        # App image build
#        - "docker build -t ${CI_REGISTRY_IMAGE} -f .docker/nginx-static/Dockerfile ."
#        - "docker tag ${CI_REGISTRY_IMAGE} ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
#        - "docker push ${CI_REGISTRY_IMAGE}:latest"
#        - "docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
